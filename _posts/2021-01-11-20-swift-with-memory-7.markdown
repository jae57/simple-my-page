---
layout: post
title: Swift 와 메모리 구조
date: 2021-01-11 20:29:55 +0900
image: "/images/7.jpg"
tags: Study
featured: false
---

Swift의 각 변수와 객체들은 메모리의 어느 영역에 위치하며, 위치와 크기는 언제 결정될까?

메모리 구조

코드영역: 기계어 코드가 들어있다. CPU는 이 영역에 저장된 명령어를 하나씩 가져가서 처리한다.
데이터영역 : 데이터를 저장한다. static변수, 모든 지역함수 바깥에 선언된 전역변수를 할당한다. 프로그램 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
Stack - 함수 내에 선언된 지역 변수들과 매개변수가 저장되는 공간. 자료구조 특성 상 삽입과 삭제가 TOP에서만 이루어짐-> 1명령만으로 메모리 조작과 어드레스 조작이 가능하다. 컴파일 타임 때 크기를 결정한다 (?). 크기에 제한이 있다(넘어가면 stack overflow)
스택영역에 저장되는 함수의 호출정보를 스택프레임이라 한다.
Heap - 프로그램이 실행될 때까지 알 수 없는 가변적인 양 만큼의 데이터를 저장하기 위해 프로그램의 프로세스가 사용할 수 있도록 예약되어 있는 메인 메모리 영역 ( 그말은 Stack은 프로그램이 실행되기 전인 컴파일 시기에 데이터의 양 측정이 가능하고 크기를 결정할 수 있다?). 개체의 크기가 너무 커서 스택 할당자에 맞지 않는 경우 사용한다. 프로그래머가 할당 및 해제를 해줘야함. 런타임시에 크기가 결정된다.

Heap overflow: Heap 이 Stack 영역을 침범하는 경우
Stack overflow: Stack 이 Heap 영역을 침범하는 경우 ex. 재귀호출 무한 반복

- 힙과 스택의 속도차이 원인
  heap 은 페이지 폴트를 발생시킬 수 잇으나 stack 은 그렇지 않다
  스택이 빠르다는 것이 다른 세그먼트와 다르게 push, pop 하나만으로 0-address 명령어를 사용할 수 있어서 빠른 것입니다.
  chunk 형 데이터나 object에 접근하는 것은 똑같이 하나 이상의 주소 변수 전환을 통해 접근하므로 접근속도는 같다
  할당에 들어가는 cost 를 피하기 위해서는 메모리 풀을 사용하는데 메모리 풀을 이용하는 것은 memory fragmentation을 피해야 한다는 의미다.
  stack 을 이용하는 것은 할당을 하지 않으며, memory fragmentation 문제도 없다
  stack 내 객체들은 CPU 의 L1 캐시에 담길 확률이 heap 에 있는 객체들에 비해 훨씬 높기 때문에 접근속도가 더 빠르다
  ---_ 다시 말해, 힙의 속도 저하 요인 _ 힙은 여러 쓰레드에서의 접근을 어찌 대처하는지?

1. 할당작업으로 인한 속도 저하
   블록이 사용 가능한 목록에 없을 경우, 런타임 할당자 코드에서 사용가능한 더 큰 블록을 찾거나 새 블록을 할당받아야하기 때문에 이에 주기가 소요된다.
2. 해제작업으로 인한 속도 저하
   병합을 사용할 때 작업에 더 많은 주기가 소요된다. 병합하는 동안 각 해제 작업에서는 해당 인접 항목을 찾아내어 더 큰 블록을 만들고,
   그 블록을 해제목록에 다시 삽입한다. 그러한 찾기가 소요되는 동안에는 메모리가 임의의 순서로 액세스되어 캐시 누락이 발생하고 성능이 저하될 수 있다.
3. 힙 손상으로 인한 속도 저하
   응용 프로그램에서 힙 블록을 적절하게 사용하지 않을 경우 힙이 손상된다. 가장 많이 발생할 수 있는 힙 손상 문제로는 이중해제, 해제 후 블록 사용, 블록 경를 벗어나 덮어쓰기 등이 있다
4. 힙 경합으로 인한 속도 저하
   두 개 이상의 스레드에서 동시에 데이터에 액세스 하려고 하면 경합이 발생하여 한 쪽 스레드의 작업이 완료되어야 다른 쪽 스레드의 작업이 진행될 수 있다
   경합으로 인해 항상 문제가 발생하며, 이 문제는 현재 다중 프로세서 시스템에서 일어나는 문제 중 가장 큰 문제다
   메모리 블록을 아주 많이 사용하는 응용프로그램이나 DLL이 여러 개의 스레드로 실행되거나 다중 프로세서 시스템에서 실행되면 속도가 느려진다. 이 문제를 해결하려면 일반적으로 단일 잠금 방법을 사용하여 해당 힙을 사용하는 모든 작업을 serialize 한다(작업을 serialize하는게 뭐길래 스레드가 잠금을 기다리는 동안 컨텍스트를 전환할 수 있다는 건지 모르겟음). 이러한 serialization 으로 인해 스레드에서는 잠금을 기다리는 동안 컨텍스트를 전환할 수 있다.
   경합은 일반적으로 스레드와 프로세스의 컨텍스트 전환(스레드끼리는 컨텍스트 전환을 안해도 되지 않나? 공유영역이 있으니까?)을 가져온다. 컨텍스트 전환에도 리소스가 많이 소모되지만, 프로세서 캐시에서 데이터가 손실되어 나중에 해당 스레드가 다시 살아날 때 이 데이터를 다시 작성하는 데에 리소스가 훨씬 많이 소모된다.

> 그런데도 Heap 영역, 동적 할당은 왜 필요한가?
> 메모리를 효율적으로 관리할 수 있다
> ( 예시, 임베디드 시스템의 경우 개발하다보면
> 하드웨어리 크기가 매우 작은 경우가 많은데
> 이 경우 메모리 용량도 역시 작다.
> 이렇게 작은 메모리 공간을 컴파일러가 자동으로
> 관리해주는 것보다 프로그래머가 관리한다면
> 더 효율적인 관리가 가능)




참고
[C언어 메모리 구조](https://surhommejk.tistory.com/121)
[힙과 스택의 최대 할당 크기](https://bozeury.tistory.com/entry/%ED%9E%99Heap%EA%B3%BC-%EC%8A%A4%ED%83%9DStack%EC%9D%98-%EC%B5%9C%EB%8C%80-%ED%81%AC%EA%B8%B0#:~:text=%EB%B3%B4%ED%86%B5%20%EB%B9%84%EC%A3%BC%EC%96%BC%20%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EC%97%90%EC%84%9C%EB%8A%94%20%EB%94%94%ED%8F%B4%ED%8A%B8,%EC%A6%89%2C%20%EC%95%BD%201MB%EC%A0%95%EB%8F%84%20%EB%90%9C%EB%8B%A4.)
[메모리 할당](https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/#:~:text=Heap%20Allocation%20%3A%20The%20memory%20is,to%20allocated%20and%20de%2Dallocate.)

스택의 크기는 컴파일타임에 결정된다고 하는데
그렇다면 아래의 경우 String 의 크기를 모른다면 어떻게 ??
struct Person {
  static let koreanWord = "사람"		// B (B-1 : koreanWord / B-2 : "사람")
  var name: String		// C
}
또한 swift 에서 struct는 
참고할만한 링크 [](https://big-blog.tistory.com/m/3736)
이 글에서 말하는 걸 보자면 컴파일시점에 가상으로 메모리 상의 위치나 할당할 크기등을 미리 계산해두고 
실제 실행했을 때 실 메모리 주소와 매핑을 하게되고 값 할당 역시 런타임때 진행된다
다만 미리 상대적인 메모리 위치와 할당할 크기 계산이 컴파일 때 이뤄지기 때문에 런타임때는 할당에 있어서
힙보다 빠르다